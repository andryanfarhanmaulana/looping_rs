# looping_rs

**Симулятор Слушателя Событий для Cross-Chain Моста**

Этот репозиторий содержит комплексный Python-скрипт, симулирующий работу бэкенд-компонента (слушателя событий) для кросс-чейн моста между двумя EVM-совместимыми блокчейнами (например, Ethereum и Polygon).

---

## Концепция

Кросс-чейн мосты — это критически важные элементы инфраструктуры Web3, позволяющие передавать активы и данные между различными блокчейнами. Их надежная работа зависит от оффчейн-компонентов, которые отслеживают события в одной сети и инициируют соответствующие действия в другой.

Данный скрипт имитирует именно такой компонент. Его задача — подключаться к двум сетям и выполнять следующие функции:

1.  **Слушать события `TokensLocked`** в контракте моста на *исходной сети* (Source Chain). Это событие означает, что пользователь заблокировал свои токены для их последующего переноса.
2.  **Слушать события `TokensUnlocked`** в контракте моста на *целевой сети* (Target Chain). Это событие подтверждает, что эквивалентные токены были выпущены (разблокированы) для пользователя.
3.  **Вести учет состояния** каждой кросс-чейн транзакции, отслеживая ее жизненный цикл от блокировки до разблокировки.
4.  **Обеспечивать отказоустойчивость** при проблемах с подключением к RPC-узлам и потенциальных реорганизациях блоков.

## Архитектура кода

Скрипт спроектирован с использованием объектно-ориентированного подхода для разделения ответственности и повышения модульности. Основные компоненты архитектуры:

-   `CrossChainOrchestrator`: Главный класс, который инициализирует и координирует работу всех остальных компонентов. Он запускает два слушателя (по одному на каждую сеть) и управляет их жизненным циклом.

-   `ChainEventListener`: Основной рабочий компонент для одной сети. Он работает в асинхронном цикле, опрашивая RPC-узел на предмет новых блоков, сканирует их на наличие нужных событий и передает их на обработку.

-   `EventProcessor`: Центральный обработчик состояния. Он получает события от обоих слушателей и обновляет внутреннюю базу данных транзакций (в данной симуляции — словарь в памяти). Это позволяет отслеживать, какие транзакции находятся в ожидании, а какие уже завершены.

-   `EVMChainConnector`: Класс-коннектор, отвечающий за всю низкоуровневую логику взаимодействия с блокчейном через `web3.py`. Он управляет подключением к RPC-узлу и предоставляет интерфейс для получения блоков и взаимодействия с контрактами.

-   `CrossChainTransaction`: Структура данных (`dataclass`) для хранения полной информации о кросс-чейн переводе.

Схема взаимодействия компонентов:

```
[CrossChainOrchestrator]
       |
+------+-----------------+
|                        |
v                        v
[ChainEventListener 1]   [ChainEventListener 2]  <--> [ EventProcessor ]
(Source Chain)           (Target Chain)                 (Shared State)
|                        |
|                        |
v                        v
[EVMChainConnector]      [EVMChainConnector]
(web3.py)                (web3.py)
```

Ключевой особенностью является использование `asyncio` для асинхронной и одновременной работы с обеими сетями, что обеспечивает высокую производительность и отзывчивость системы.

## Принцип работы

1.  **Инициализация**: `CrossChainOrchestrator` создает экземпляры слушателей для исходной и целевой сетей, а также общий `EventProcessor` для управления состоянием.

2.  **Подключение**: Каждый `ChainEventListener` через `EVMChainConnector` устанавливает соединение со своим RPC-узлом. В случае сбоя предусмотрены повторные попытки подключения.

3.  **Определение начального блока**: Слушатель определяет номер последнего блока в сети и начинает сканирование с небольшим отставанием (`confirmation_blocks`), чтобы минимизировать риск обработки событий из блоков, которые могут быть отменены в результате реорганизации (reorg).

4.  **Цикл опроса (Polling Loop)**: В бесконечном асинхронном цикле каждый слушатель:
    -   Запрашивает номер последнего блока.
    -   Если появились новые подтвержденные блоки, он сканирует этот диапазон на наличие событий (`TokensLocked` или `TokensUnlocked`) в смарт-контракте моста.
    -   Пауза на заданный интервал (`poll_interval_seconds`).

5.  **Обработка событий**: Найденные события передаются в `EventProcessor`.
    -   При получении `TokensLocked`, процессор создает новую транзакцию со статусом `PENDING`.
    -   При получении `TokensUnlocked`, процессор находит соответствующую транзакцию по ее ID и обновляет ее статус на `COMPLETED`.

6.  **Симуляция**: Для наглядной демонстрации работы в скрипт встроен симулятор, который периодически генерирует фиктивные события `TokensLocked` и `TokensUnlocked`, имитируя активность пользователей моста.

## Пример использования

### 1. Клонирование репозитория

```bash
git clone https://github.com/example/looping_rs.git
cd looping_rs
```

### 2. Установка зависимостей

Убедитесь, что у вас установлен Python 3.8+ и pip. Создайте виртуальное окружение и установите зависимости.

```bash
python -m venv venv
source venv/bin/activate  # Для Windows: venv\Scripts\activate
pip install -r requirements.txt
```

### 3. Конфигурация

Откройте файл `script.py`. В секции `CONFIGURATION` находится словарь `CONFIG`. Для симуляции используются публичные RPC-узлы и фиктивные адреса контрактов. **Вам не нужно ничего менять для первого запуска.**

Для подключения к реальным сетям или использования с настоящим мостом, вам потребуется:
-   Указать URL ваших RPC-узлов (например, от Infura или Alchemy).
-   Вставить корректные адреса смарт-контрактов моста для исходной и целевой сетей.
-   Предоставить полный ABI контракта в переменной `DUMMY_BRIDGE_ABI` (сейчас там только определения событий).

### 4. Запуск скрипта

Запустите скрипт из терминала:

```bash
python script.py
```

### 5. Пример вывода в консоли

Вы увидите логи, показывающие процесс подключения, сканирования блоков и обработки симулированных событий.

```
2023-10-27 15:30:00 - INFO:CrossChainOrchestrator: Запуск оркестратора Cross-Chain Bridge Listener...
2023-10-27 15:30:02 - INFO:EthereumConnector: Успешное подключение к Ethereum. ChainID: 1
2023-10-27 15:30:02 - INFO:EthereumListener: Инициализация слушателя для Ethereum. Начальный блок: 18450100 (Последний: 18450105)
2023-10-27 15:30:03 - INFO:PolygonConnector: Успешное подключение к Polygon. ChainID: 137
2023-10-27 15:30:03 - INFO:PolygonListener: Инициализация слушателя для Polygon. Начальный блок: 49872350 (Последний: 49872360)
... 
2023-10-27 15:30:25 - INFO:EventProcessor: РЕГИСТРАЦИЯ БЛОКИРОВКИ: TxID [0x1a2b3c4d5e...] | Пользователь [0xAbCd...EfGh] | Сумма [150.7500] | Из [Ethereum] -> В [Polygon]. Статус: PENDING.
...
2023-10-27 15:30:35 - INFO:EventProcessor: ПОДТВЕРЖДЕНИЕ РАЗБЛОКИРОВКИ: TxID [0x1a2b3c4d5e...] | Статус изменен на COMPLETED.
...
2023-10-27 15:31:03 - INFO:EventProcessor: Сводка состояния: PENDING: 1, COMPLETED: 1
```

Для остановки скрипта нажмите `Ctrl+C`. Произойдет корректное завершение всех асинхронных задач.